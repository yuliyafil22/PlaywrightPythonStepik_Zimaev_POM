Page Object Model (POM)?
Page Object Model (POM) - это популярный паттерн проектирования, используемый в автоматизации тестирования
веб-приложений. Его основная цель - упрощение и улучшение организации тестового кода. В POM каждая веб-страница
представлена как отдельный объект класса, который содержит методы взаимодействия с элементами этой страницы.
Это помогает сделать тесты более читаемыми, поддерживаемыми и удобными для повторного использования.

Зачем нужен Page Object Model
Улучшение читаемости кода: POM помогает структурировать тестовый код таким образом, что действия и элементы 
на странице инкапсулируются в одном месте. Это делает тесты более понятными и легкими для чтения.
Повышение уровня абстракции: Паттерн позволяет отделить логику тестов от логики взаимодействия с веб-страницами.
Это упрощает поддержку тестов и позволяет концентрироваться на тестовых сценариях, а не на деталях реализации 
взаимодействия с UI.
Повышение удобства поддержки: Изменения в структуре страницы требуют обновлений только в соответствующих
классах Page Object, а не в каждом тесте, что существенно снижает время и усилия, необходимые для поддержки
тестов.
Основные компоненты Page Object Model
Классы страниц (Page Classes): Каждая веб-страница представлена как класс. Этот класс содержит элементы 
страницы (в виде переменных) и методы для взаимодействия с ними.
Тестовые сценарии (Test Scripts): Тесты, которые используют объекты классов страниц для выполнения действий 
и проверки результатов.

Что такое параметризация тестов?

Параметризация тестов позволяет запускать одну и ту же тестовую функцию с разными наборами входных данных. Это особенно полезно, когда вы хотите проверить, что ваш код работает корректно для разных сценариев.
Вместо того чтобы создавать отдельные тестовые функции для каждого набора данных, вы можете использовать параметризацию, чтобы сократить дублирование кода и улучшить общую структуру тестов.
Pytest позволяет параметризовать тесты. Это делается с помощью декоратора @pytest.mark.parametrize.

Как использовать @pytest.mark.parametrize?

Импортируйте библиотеку pytest.
Определите тестовую функцию и добавьте перед ней декоратор @pytest.mark.parametrize.
В аргументах декоратора укажите имена параметров и соответствующие значения для каждого набора данных.
Пример: Вот пример тестовой функции, которая использует параметризацию:

# project/tests/test_login.py
import pytest
from pages.login_page import LoginPage
from pages.dashboard_page import DashboardPage


@pytest.mark.parametrize('username, password', [
    ('user', 'user'),
    ('admin', 'admin')
])
def test_login_success(page, username, password):
    login_page = LoginPage(page)
    dashboard_page = DashboardPage(page)

    login_page.navigate()
    login_page.login(username, password)

    dashboard_page.assert_welcome_message(f"Welcome {username}")
В этом тесте:

Используется декоратор pytest.mark.parametrize для задания нескольких наборов данных.
Тест запускается для каждой пары username и password.


Использование фикстур для инициализации страниц
Фикстуры позволяют инициализировать объекты, которые затем могут быть использованы в тестах. Это улучшает читаемость и уменьшает дублирование кода.

Создайте в корне проекта файл conftest.py и разместите следующий код

# project/conftest.py
import pytest
from pages.login_page import LoginPage
from pages.dashboard_page import DashboardPage


@pytest.fixture
def login_page(page):
    return LoginPage(page)


@pytest.fixture
def dashboard_page(page):
    return DashboardPage(page)
Эти фикстуры создают экземпляры LoginPage и DashboardPage, которые могут быть использованы в тестах.
